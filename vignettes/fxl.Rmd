---
title: "Faux Excel (fxl) Charting in R"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Faux Excel (fxl) Charting in R}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# The rationale for *fxl* and Novel Methods

Single-case research designs involve the presentation of empirical data across experimental conditions to visually draw inferences regarding the effects of environmental manipulations on observed behavior. The empirical data featured in these designs are presented using various that have been shaped by decades of research and practice in behavior analysis. Many of these conventions are highly specialized and are not natively supported in any existing software package (e.g., phase change lines being drawn across multiple individual plots). Even though methods exist for accommodating these conventions in spreadsheet software, these are all tedious and effortful and subsequent modifications typically require additional human interaction to edit. Various scripts and macros have been suggested to streamline these efforts; however, these are at best incomplete at best and a security threat at worst. Indeed, most organizations disable the use of macros by default for all users. The *fxl* package was designed to meet this gap in available and accessible tools.

## Primary Goals of *fxl* Package

Various methods exist for visualizing the results of clinical work and research using single-case designs and visual analysis. However, most of these approaches are limited in flexibility, reproducibility, and security. The methods and design of the package have been designed to accomplish several goals.

### Goal #1: Transparency and Replicability

Visualizations of single-case designs are carefully constructed from empirical data to support visual analysis. This is potentially problematic from a reproducibility standpoint, as these types of figures are traditionally constructed by hand and cannot be fully reproduced without direct access to the exact spreadsheet from which the figure was developed. Furthermore, even with direct access to the exact spreadsheet, changes cannot be audited and documented over time and this further hinders efforts at transparency.

The *fxl* package was designed to address these shortcomings by leveraging the transparency and replicability of the *R Statistical Program* and supporting the drawing of single case design figures using *R* syntax only. This syntax-forward approach also allows researchers to pre-register their design specifications and visualizations in an attempt to better distinguish exploratory vs hypothesis testing research.

### Goal #2: Access to Single Case Conventions

Manual construction of single case plots, even when using templates, entails an array of monotonous and tedious tasks that must be performed by hand. Various features of these figures must be generated by hand using methods that were not originally designed for such purposes (e.g., combining multiple plots into a single plot). This is not an efficient use of clinical or research time.

The package was developed to provide access to methods specifically designed to feature the conventions not supported elsewhere. These methods are provided 'out-of-the-box' to make these conventions more accessible and more efficient for researchers and clinicians.

### Goal #3: Support for Dynamic Reporting

Attempts to scale interventions and clinical/educational programming based on single case designs and visual analysis have traditionally been difficult due to the efforts and consideration required for visual analysis. Generally, most clinicians working with many cases typically track and monitor the results of intervention using individual spreadsheets. That is, much of this work is unnecessarily duplicated and this is introduces a significant source of inefficiency at scale.

The *fxl* package was designed to be compatible with *RMarkdown* and *Quarto* to support dynamic reports that can simultaneously visualize progress for multiple individuals (e.g., students in a classroom) as well as multiple groups (e.g., across classrooms in a grade). Specifically, *fxl* was designed to be able to be used in a way that scaled effectively in ways that other, earlier methods for drawing single case design figures did not. Similarly, this approach can be used to draw reports that are up-to-date, drawn in lossless quality, and built to scale as new students are added to the caseload.

## Syntax and General Code Structure

The *fxl* package was constructed to use a functional approach to *R* and makes heavy use of the \`\|\>\` pipe operator to streamline the expressiveness of the syntax. For users of the *ggplot2* package, the general logic and workflow are almost identical. That is, a general object is created (e.g., 'fxl' class in *fxl* as opposed to 'ggproto' in *ggplot2*) and layers are added to the object to tailor what is drawn upon the figure (e.g., markers, lines, annotations) and adjust other features of the figure (e.g., spacing, coordinate limits).

The high degree of overlap observed with *ggplot2* was due to two reasons. First, the initial design used *ggplot2* as a base and focused on extending the package to support conventions common in single-case research designs. However, low-level conventions regarding how individual facets were drawn limited options for drawing cross-plot features (e.g., staggered phase change lines across plots). Considerable work was done here, but a dedicated drawing algorithm using base *R* methods needed to be developed to fully incorporate all desired plotting features. Second, the workflow and usage patterns common in *ggplot2* were emulated to assist users of *ggplot2* in using *fxl* if and when they needed access to a plotting engine that supports those conventions (e.g., generating figures that meet publication standards).

### Core Plotting Object

The core plotting object for the figure is produced using the *scr_plot* call with the required arguments. The *required* arguments include a valid dataframe with relevant data as well as a list of aesthetics that direct the engine on how to visualize that data (e.g., which data corresponds with the x-axis). Other arguments are also available to further customize the plot (e.g., margins), but only these are *required* to produce the core object.

An example of this is provided below:

```{r, eval=FALSE}
scr_plot(
  Gilroyetal2015, # Data frame (long format)
  aesthetics = var_map(
    x = Session, # Column name for x-axis values
    y = Responding, # Column name for y-axis values
    p = Condition, # Column name for phases associated with x-y coordinates
    facet = Participant # Column name distinguishing individual plots/facets
  )
)
```

### Adding Drawing Layers to Core Plotting Object

The core plotting object alone will rarely provide a sufficient visualization of the supplied data and layers can be added to the object to further refine the end result. That is, despite the core object being provided with x-y coordinate data, no specific instructions to draw are provided without specific instructions. Layers to add the drawing of markers (*scr_points*), lines (*scr_lines*), or alter any other relevant feature of the figure must be specified in the call.

An example that builds from the previous example and adds points and lines is provided below:

```{r eval=FALSE}
scr_plot(
  Gilroyetal2015, 
  aesthetics = var_map(
    x = Session, 
    y = Responding, 
    p = Condition, 
    facet = Participant 
  )
) |>
scr_points(cex = 2) |> # plot points, using x/y from aesthetics
scr_lines(size = 1) # plot line, using x/y from aesthetics
```

As an added note, it warrants stating clearly that the sequence (i.e., the call must begin with *scr_plot*) and chain of calls are relevant to how the program works (i.e., all are linked together by the native *R* pipe operator '\|\>'). The pipe operator should be used to connect calls in the sequence; however, the historical '%\>%' operator from *magittr* could also be used if desired (but is not generally recommended). Additionally, the *order* of layers is also relevant because layers added earlier with be drawn earlier (i.e., lower *z-index*) and layers added later will be drawn later (i.e., higher *z-index*).

### Customizing Labels and Axes

The default behavior of the drawing engine is to draw axes using the names supplied to x-y coordinate variables and use the domains and ranges specified by the data supplied. Occasionally, the visualization of these data may be more understandable to set to a different set of extremes (i.e., round to a number maximum divisible by 10; e.g., 100 instead of 97). Various calls exist to override the range of axes (i.e., *scr_xoverride*, *scr_yoverride*), the labels for those axes (i.e., *scr_xlabel*, *scr_ylabel*), and the title of the overall figure (i.e., *scr_title*).

An example that builds from the previous examples and customizes the axes titles, ticks, and figure title is provided below:

```{r eval=FALSE}
scr_plot(
  Gilroyetal2015, 
  aesthetics = var_map(
    x = Session, 
    y = Responding, 
    p = Condition, 
    facet = Participant 
  )
) |>
scr_points(cex = 2) |> # plot points, using x/y from aesthetics
scr_lines(size = 1) |> # plot line, using x/y from aesthetics
scr_xoverride(c(0.25, 27.5),
  xticks = 1:27,
  xtickslabs = as.character(1:27)
) |> # manually override x-axis (make extra room for labels) and specify ticks
scr_yoverride(c(-5, 105), 
  yticks = seq(0, 100, by = 10),
  ytickslabs = as.character(seq(0, 100, by = 10)),
) |> # manually override y-axis and tick interval (tick for every 10 units)
scr_xlabel("Session") |> # Override x-axis label (bottom only shown by default)
scr_ylabel("Percent Accuracy") |> # Override y-axis label (centered, leftmost label)
scr_title("Rates of Acquisition across Participants") 

```

# Example Figure Output

## Functional Analysis; Gilroy et al. (2019)

The *fxl* package includes tools specific to the charting of functional analyses. Briefly, a variety of conventions exist regarding the markers and colors associated with specific environmental manipulations. Methods included in the *plotMultiElementFA* function detect conditions and apply such styles in an automated manner.

For convenience, an analog function analysis published Gilroy et al. (2019) is illustrated below (doi: <https://doi.org/10.1080/17518423.2019.1646342>):

```{r, fig.width=8, fig.height=6, warning=FALSE, eval=FALSE}

library(fxl)

plotMultiElementFA(Gilroyetal2019,
 grouping = "Condition",
 session  = "Session",
 response = "CTB",
 title    = "Functional Analysis",
 xlab     = "Session",
 ylab     = "Frequency (Responses, Reinforcers Delivered)",
 ylims    = c(0, 4),
 legend.position = "topright")

```

## Annotated Reversal Design; Gilroy et al. (2019)

The *fxl* package supports annotating figures (i.e., drawing labels, text) when conventions such as legends are inefficient in terms of communicating ecological modification. In these situations, a variety of behavior analytic conventions are applied by directly drawing upon a panel. This approach, an annotated reversal figure, is supported with the *plotAnnotatedReversal* function.

For convenience, an annotated reversal (treatment evaluation) published in Gilroy et al. (2019) is illustrated below (doi: <https://doi.org/10.1080/17518423.2019.1646342>):

```{r, fig.width=10, fig.height=8, warning=FALSE, eval=FALSE}

condition_label <- data.frame(
  Panel = rep("Attention", 11),
  X     = c(17.5,
            23.5,
            37.5,
            72.5,
            85,
            39, 57.5, 74,
            9.5,
            22,
            33),
  Y     = c(3.3,
            3,
            3,
            3,
            3,
            2.05, 2.05, 2.05,
            1.5,
            2.25,
            2.15),
  Cex   = rep(0.75, 11),
  Text  = c("Baseline",
            "FCR-A + EXT",
            "FCR-A + EXT",
            "Parent-Implementation",
            "Generalization",
            "5s",
            "Schedule Thinning",
            "300s",
            "Problem Behavior",
            "FCR-A",
            "Add FCR\r\nOptions"),
  Srt  = rep(0, 11)
)

condition_label2 <- data.frame(
  Panel = rep("Demand", 10),
  X     = c(35,
            50.5,
            65,
            85,
            30, 60, 71,
            26,
            36.5,
            47.5),
  Y     = c(3.35,
            3.25,
            3,
            3,
            1.3, 1.3, 1.3,
            2,
            2.4,
            1.5),
  Cex   = rep(0.75, 10),
  Text  = c("FCR-E + EXT",
            "FCR-A/E + EXT",
            "Parent-Implementation",
            "Generalization",
            "1",
            "Demand Fading",
            "6",
            "FCR-E",
            "FCR-A P = 0.1",
            "FCR-A\r\nP = 0.1\r\n200% SR"),
  Srt  = c(rep(0, 8),
           90,
           0)
)

condition_label <- rbind(
  condition_label,
  condition_label2
)

panel_label <- data.frame(
  Panel = c("Attention",
            "Demand"),
  X     = rep(95, 2),
  Y     = rep(3.25, 2),
  Cex   = rep(1.25, 2),
  Text  = c("Attention",
            "Demand")
)

annotate_phase_lines <- data.frame(
  Panel = c(rep("Attention", 2),
            rep("Demand", 5)),
  X     = c(58.5, 74.5,
            34.5, 37.5, 41.5, 50.5, 72.5),
  Lty   = c(2, 2,
            1, 1, 1, 2, 2)
)

annotate_brackets <- data.frame(
  Panel = c("Attention",
            "Demand",
            "Demand",
            "Attention",
            "Demand",
            "Attention",
            "Attention",
            "Attention",
            "Demand",
            "Demand",
            "Demand"),
  X1    = c(5,
            22.5,
            36.5,
            38,
            29,
            7,
            20,
            31,
            24,
            36,
            45.5),
  X2    = c(26.25,
            39.5,
            47.5,
            74,
            72,
            7,
            20,
            31,
            24,
            36,
            45.5),
  Y1    = c(3.175,
            3.275,
            3.175,
            2,
            1.25,
            1.4,
            2.15,
            2.1,
            1.9,
            1.35,
            1.35),
  Y2    = c(2.95,
            2.95,
            2.85,
            1.25,
            0.5,
            0.75,
            1.9,
            1.9,
            1.35,
            0.75,
            0.65),
  Lty   = c(1, 1, 1,
            2, 2,
            1, 1, 1,
            1, 1, 1)
)

plotAnnotatedReversal(data      = Gilroyetal2019Tx,
                      grouping  = "Participant",
                      session   = "Session",
                      response  = "CTB",
                      response2 = "FCR",
                      response3 = "FCR2",
                      condCol   = "Condition",
                      pnum      = "PhaseNum",
                      poff      = "LineOff",
                      title     = "Evaluation of FCT Treatment Package",
                      xlab      = "Session",
                      ylab      = "Problem Behavior per Minute",
                      deltaX    = 10,
                      ymins     = list("Attention" = 0,
                                       "Demand"   = 0),
                      ymaxs     = list("Attention" = 3,
                                       "Demand"   = 3),
                      clabs     = condition_label,
                      plabs     = panel_label,
                      alines    = annotate_phase_lines,
                      abracks   = annotate_brackets)

```

## Multiple Baseline; Gilroy et al. (2015)

One of the most irritating aspects of single-case design is the plotting of condition changes. Specifically, across-panel drawing is an rare practice and rarely any software has been designed to support such practices. The *fxl* package includes methods that enable pixel-perfect drawing of phase/condition changes using straightforward conventions. Briefly, data are loaded into a data frame by panel (e.g., name), session number, condition (e.g., baseline), and phase number (e.g., 1, 2). Constructed in this way, R can look to see who changes in phases can be drawn and the linked together.

For convenience, a multiple baseline design published in Gilroy et al. (2015) is illustrated below (doi: <http://dx.doi.org/10.1016/j.rasd.2015.04.004>):

```{r, fig.width=8, fig.height=6, warning=FALSE, eval=FALSE}

# Specify location, text, and aesthetics of condition labels
condition_labels <- data.frame(
  Panel = rep("Andrew", 4),         # Only on top row (for andrew)
  X     = c(3.5,                    # Positioned between phase change lines
            9,
            19,
            27),
  Y     = rep(100, 4),              # Positioned near top of panel
  Cex   = rep(1.25, 4),             # Slightly oversized for clarity
  Text  = c("Baseline",             # Content of phase labels
            "Training",
            "Post-Training",
            "Generalization")
)

# Specify location, text, and aesthetics of panel labels
panel_labels <- data.frame(
  Panel = c("Andrew",               # Specify the panels to draw upon
            "Brian",
            "Charles"),
  X     = rep(27, 3),               # Positioned near right of panel edge
  Y     = c(0,                      # Positioned near the abscissa
            0,
            0),
  Cex   = rep(1.5, 3),              # Slightly oversized for clarity
  Text  = c("Andrew",               # Specific text to write
            "Brian",
            "Charles")
)

# Adding in "fake" phase data, since not all have identical exposure
data_frame_adds <- data.frame(
  Participant	= c("Andrew",         # Specify where data is associated
                  "Brian",
                  "Charles"),
  Session	    = c(23,               # Add in an "edge" at session 23 (pre-generalization probe)
                  23,
                  23),
  Condition	  = c("Generalization", # Specify condition (just for clarity sake)
                  "Maintenance",
                  "Maintenance"),
  Responding	= c(NA,               # Leave bx as NA, so nothing is plotted
                  NA,
                  NA),
  PhaseNum	  = c(3,                # Note phase index (important)
                  3,
                  4),
  LineOff     = c(0,                # Specify line offset (in case of line overlap)
                  0,
                  0)
)

# Add in the faux data, so R can guess where phase changes look best
Gilroyetal2015 <- rbind(Gilroyetal2015,
                        data_frame_adds)

plotMultipleBaseline(data     = Gilroyetal2015,
                     grouping = "Participant",
                     session  = "Session",
                     response = "Responding",
                     pnum     = "PhaseNum",
                     poff     = "LineOff",
                     ymins    = list("Andrew"  = 0,    # Set lower limits (specific to panel)
                                     "Brian"   = 0,
                                     "Charles" = 0),
                     ymaxs    = list("Andrew"  = 100,  # Set upper limits (specific to panel)
                                     "Brian"   = 100,
                                     "Charles" = 100),
                     title    = "Rates of Acquisition across Participants",
                     xlab     = "Session",
                     xmax     = 27,                    # Extend out max session, for panel tags
                     ylab     = "Percent Accuracy",
                     clabs    = condition_labels,
                     plabs    = panel_labels)

```

## Concurrent Reversal Designs; Gilroy et al. (2021)

In addition to multiple-baseline designs, single-case research may perform individual reversal designs across participants. In these cases, control is demonstrated both within- and across-participants and this warrants a slightly different charting strategy (despite keeping the same graphing conventions as the multiple baseline). However, the data supplied to *fxl* methods remains largely the same.

As an example of this, a collection of reversal designs published in Gilroy et al. (2021) are illustrated below (doi: <https://doi.org/10.1002/jaba.826>):

```{r, fig.width=8, fig.height=6, error=TRUE, warning=FALSE, eval=FALSE}

# Specify location, text, and aesthetics of condition labels
condition_label <- data.frame(
  Panel = rep("John", 6),         # Only on top row (for andrew)
  X     = c(2.5,                  # Positioned between phase change lines
            6.1,
            9,
            12.25,
            15,
            18.25),
  Y     = rep(19, 6),             # Positioned near top of (John"s) panel
  Cex   = rep(1.25, 6),           # Slightly oversized for clarity
  Text  = c("Baseline",           # Content of phase labels
            "FR-Lowest",
            "Baseline",
            "FR-Inelastic",
            "FR-Elastic",
            "FR-Inelastic")
)

# Specify location, text, and aesthetics of panel labels
panel_label <- data.frame(
  Panel = c("John",               # Specify the panels to draw upon
            "Anthony",
            "Charles"),
  X     = rep(26, 3),             # Positioned near right of panel edge
  Y     = c(5,                    # Positioned at various heights, for each case
            12,
            21),
  Cex   = rep(1.5, 3),            # Slightly oversized for clarity
  Text  = c("John",               # Specific text to write
            "Anthony",
            "Charles")
)

# Specify if/how we want to show a legend
legend_params <- data.frame(
  panel =      "John",                # legend drawn on panel for John
  position =   "topright",            # drawn in top right corner
  legend = c("Responses Observed",    # Items to draw for legend
             "Reinforcers Produced"),
  col = c("black",                    # colors to draw lines
          "black"),
  lty = c(1, 2),                      # draw solid lines
  pch = c(19, 2),                     # markers to draw
  bty = "n",                          # don"t draw surrounding box
  pt.cex = 2.25,                      # oversize markers
  cex = 1.25,                         # slightly oversize text
  text.col = "black",                 # draw text in black
  horiz = FALSE,                      # organize items vertically
  box.lty = 0                         # don"t draw surrounding box
)

plotConcurrentReversals(data     = Gilroyetal2021,
                        grouping = "Participant",
                        session  = "Session",
                        response = "Responding",
                        response2 = "Reinforcers",
                        pnum     = "PhaseNum",
                        poff     = "LineOff",
                        title    = "Individual Evaluations of Reinforcer Efficacy and Elasticity across Reinforcers",
                        xlab     = "Session",
                        ylab     = "Frequency (Responses, Reinforcers Delivered)",
                        ymins    = list("John"    = 0,
                                        "Anthony" = 0,
                                        "Charles" = 0),
                        ymaxs    = list("John"    = 20,
                                        "Anthony" = 10,
                                        "Charles" = 20),
                        clabs    = condition_label,
                        plabs    = panel_label,
                        llabs    = legend_params)
```

# Methods

## scr_plot

...

## scr_yoverride

...

## scr_xoverride

...

## scr_lines

...

## scr_points

...

## scr_plines

...

## scr_plines_mbd

...

## scr_label_facet

...

## scr_label_phase

...

## scr_arrows

...

## scr_brackets

...

## scr_guide_line

...

## scr_save

...

## scr_bar_support

...

## scr_xlabel

...

## scr_ylabel

...

## scr_title

...

## scr_legend

...

# 
